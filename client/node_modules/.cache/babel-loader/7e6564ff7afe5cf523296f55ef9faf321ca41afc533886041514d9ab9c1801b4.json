{"ast":null,"code":"var _s = $RefreshSig$();\n// useSmartScrollSnap.js\nimport { useEffect, useRef } from 'react';\nimport { gsap } from 'gsap';\n\n/**\r\n * Smart scroll snap hook.\r\n *\r\n * @param {string} selector CSS selector for snap targets (default 'section')\r\n * @param {number} duration seconds GSAP tween duration fallback to native smooth\r\n * @param {number} centerThreshold fraction (0..0.5) how far from center to force snap (short sections)\r\n * @param {number} deadZone fraction (0..0.5) central free-scroll zone for tall sections\r\n */\nexport default function useSmartScrollSnap({\n  selector = 'section',\n  duration = 0.8,\n  centerThreshold = 0.15,\n  // 15% around center\n  deadZone = 0.2 // 20% free-scroll zone inside tall sections\n} = {}) {\n  _s();\n  const sectionsRef = useRef([]);\n  const timeoutRef = useRef(null);\n  const resizeObserverRef = useRef(null);\n  useEffect(() => {\n    // helper to (re)collect current sections\n    const updateSections = () => {\n      sectionsRef.current = Array.from(document.querySelectorAll(selector));\n    };\n    updateSections();\n    window.addEventListener('resize', updateSections);\n\n    // scroll-to helper: use GSAP ScrollTo if available, otherwise native\n    const safeScrollTo = y => {\n      const top = Math.round(y);\n      try {\n        // Attempt GSAP ScrollTo (requires ScrollToPlugin to be registered)\n        gsap.to(window, {\n          duration,\n          scrollTo: {\n            y: top\n          },\n          ease: 'power2.out'\n        });\n      } catch (err) {\n        // Fallback to native smooth scroll if GSAP ScrollTo isn't available\n        try {\n          window.scrollTo({\n            top,\n            behavior: 'smooth'\n          });\n        } catch (err2) {\n          // last fallback: immediate jump\n          window.scrollTo(0, top);\n        }\n      }\n    };\n\n    // main logic executed after user stops scrolling (debounced)\n    const onScrollEnd = () => {\n      const sections = sectionsRef.current;\n      if (!sections.length) return;\n      const scrollY = window.scrollY;\n      const vh = window.innerHeight;\n\n      // find the section that contains scrollY (top <= scrollY < bottom)\n      let currentIndex = sections.findIndex(el => {\n        const top = el.offsetTop;\n        const bottom = top + el.offsetHeight;\n        return scrollY >= top && scrollY < bottom;\n      });\n\n      // if not found, pick closest\n      if (currentIndex === -1) {\n        // above first\n        if (scrollY < sections[0].offsetTop) currentIndex = 0;else currentIndex = sections.length - 1;\n      }\n      const el = sections[currentIndex];\n      const elTop = el.offsetTop;\n      const elHeight = el.offsetHeight;\n      const elBottom = elTop + elHeight;\n\n      // SHORT sections: decide based on viewport center\n      if (elHeight <= vh) {\n        const centerY = scrollY + vh / 2;\n        const centerFrac = (centerY - elTop) / elHeight; // 0..1 where center lies within section\n\n        if (centerFrac < 0.5 - centerThreshold) {\n          // center biased to top -> snap to this section top\n          safeScrollTo(elTop);\n        } else if (centerFrac > 0.5 + centerThreshold) {\n          // center biased to bottom -> snap to next section if exists\n          const next = sections[currentIndex + 1];\n          if (next) safeScrollTo(next.offsetTop);else safeScrollTo(elTop);\n        } else {\n          // center within tolerance -> do nothing\n        }\n        return;\n      }\n\n      // TALL sections: allow free scroll in central dead zone, snap near edges\n      // progress across the scrollable range inside the tall section:\n      // totalScrollable = elHeight - vh (if negative, treated as 0)\n      const totalScrollable = Math.max(0, elHeight - vh);\n      const progress = totalScrollable > 0 ? (scrollY - elTop) / totalScrollable : 0; // 0..1\n\n      if (progress < deadZone) {\n        // near top -> snap to the top of this section\n        safeScrollTo(elTop);\n      } else if (progress > 1 - deadZone) {\n        // near bottom -> snap to next section top (if exists)\n        const next = sections[currentIndex + 1];\n        if (next) safeScrollTo(next.offsetTop);else safeScrollTo(elTop);\n      } else {\n        // inside dead zone -> do nothing (allow normal scrolling)\n      }\n    };\n\n    // debounced scroll listener\n    const onScroll = () => {\n      if (timeoutRef.current) clearTimeout(timeoutRef.current);\n      timeoutRef.current = setTimeout(() => {\n        onScrollEnd();\n      }, 120); // small debounce to catch scroll-end\n    };\n    window.addEventListener('scroll', onScroll, {\n      passive: true\n    });\n\n    // cleanup\n    return () => {\n      window.removeEventListener('scroll', onScroll);\n      window.removeEventListener('resize', updateSections);\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n        timeoutRef.current = null;\n      }\n      // if you used any observers, disconnect here (not used now)\n      if (resizeObserverRef.current) {\n        resizeObserverRef.current.disconnect();\n        resizeObserverRef.current = null;\n      }\n    };\n  }, [selector, duration, centerThreshold, deadZone]);\n}\n_s(useSmartScrollSnap, \"M+ZAbBfb3XKdzSp9w8kvD71zii0=\");","map":{"version":3,"names":["useEffect","useRef","gsap","useSmartScrollSnap","selector","duration","centerThreshold","deadZone","_s","sectionsRef","timeoutRef","resizeObserverRef","updateSections","current","Array","from","document","querySelectorAll","window","addEventListener","safeScrollTo","y","top","Math","round","to","scrollTo","ease","err","behavior","err2","onScrollEnd","sections","length","scrollY","vh","innerHeight","currentIndex","findIndex","el","offsetTop","bottom","offsetHeight","elTop","elHeight","elBottom","centerY","centerFrac","next","totalScrollable","max","progress","onScroll","clearTimeout","setTimeout","passive","removeEventListener","disconnect"],"sources":["C:/Users/georg/projects/Fullstack/portofolio-2.0/client/src/components/useScrollSnap.js"],"sourcesContent":["// useSmartScrollSnap.js\r\nimport { useEffect, useRef } from 'react';\r\nimport { gsap } from 'gsap';\r\n\r\n/**\r\n * Smart scroll snap hook.\r\n *\r\n * @param {string} selector CSS selector for snap targets (default 'section')\r\n * @param {number} duration seconds GSAP tween duration fallback to native smooth\r\n * @param {number} centerThreshold fraction (0..0.5) how far from center to force snap (short sections)\r\n * @param {number} deadZone fraction (0..0.5) central free-scroll zone for tall sections\r\n */\r\nexport default function useSmartScrollSnap({\r\n  selector = 'section',\r\n  duration = 0.8,\r\n  centerThreshold = 0.15, // 15% around center\r\n  deadZone = 0.2 // 20% free-scroll zone inside tall sections\r\n} = {}) {\r\n  const sectionsRef = useRef([]);\r\n  const timeoutRef = useRef(null);\r\n  const resizeObserverRef = useRef(null);\r\n\r\n  useEffect(() => {\r\n    // helper to (re)collect current sections\r\n    const updateSections = () => {\r\n      sectionsRef.current = Array.from(document.querySelectorAll(selector));\r\n    };\r\n\r\n    updateSections();\r\n    window.addEventListener('resize', updateSections);\r\n\r\n    // scroll-to helper: use GSAP ScrollTo if available, otherwise native\r\n    const safeScrollTo = (y) => {\r\n      const top = Math.round(y);\r\n      try {\r\n        // Attempt GSAP ScrollTo (requires ScrollToPlugin to be registered)\r\n        gsap.to(window, {\r\n          duration,\r\n          scrollTo: { y: top },\r\n          ease: 'power2.out'\r\n        });\r\n      } catch (err) {\r\n        // Fallback to native smooth scroll if GSAP ScrollTo isn't available\r\n        try {\r\n          window.scrollTo({ top, behavior: 'smooth' });\r\n        } catch (err2) {\r\n          // last fallback: immediate jump\r\n          window.scrollTo(0, top);\r\n        }\r\n      }\r\n    };\r\n\r\n    // main logic executed after user stops scrolling (debounced)\r\n    const onScrollEnd = () => {\r\n      const sections = sectionsRef.current;\r\n      if (!sections.length) return;\r\n\r\n      const scrollY = window.scrollY;\r\n      const vh = window.innerHeight;\r\n\r\n      // find the section that contains scrollY (top <= scrollY < bottom)\r\n      let currentIndex = sections.findIndex((el) => {\r\n        const top = el.offsetTop;\r\n        const bottom = top + el.offsetHeight;\r\n        return scrollY >= top && scrollY < bottom;\r\n      });\r\n\r\n      // if not found, pick closest\r\n      if (currentIndex === -1) {\r\n        // above first\r\n        if (scrollY < sections[0].offsetTop) currentIndex = 0;\r\n        else currentIndex = sections.length - 1;\r\n      }\r\n\r\n      const el = sections[currentIndex];\r\n      const elTop = el.offsetTop;\r\n      const elHeight = el.offsetHeight;\r\n      const elBottom = elTop + elHeight;\r\n\r\n      // SHORT sections: decide based on viewport center\r\n      if (elHeight <= vh) {\r\n        const centerY = scrollY + vh / 2;\r\n        const centerFrac = (centerY - elTop) / elHeight; // 0..1 where center lies within section\r\n\r\n        if (centerFrac < 0.5 - centerThreshold) {\r\n          // center biased to top -> snap to this section top\r\n          safeScrollTo(elTop);\r\n        } else if (centerFrac > 0.5 + centerThreshold) {\r\n          // center biased to bottom -> snap to next section if exists\r\n          const next = sections[currentIndex + 1];\r\n          if (next) safeScrollTo(next.offsetTop);\r\n          else safeScrollTo(elTop);\r\n        } else {\r\n          // center within tolerance -> do nothing\r\n        }\r\n\r\n        return;\r\n      }\r\n\r\n      // TALL sections: allow free scroll in central dead zone, snap near edges\r\n      // progress across the scrollable range inside the tall section:\r\n      // totalScrollable = elHeight - vh (if negative, treated as 0)\r\n      const totalScrollable = Math.max(0, elHeight - vh);\r\n      const progress = totalScrollable > 0 ? (scrollY - elTop) / totalScrollable : 0; // 0..1\r\n\r\n      if (progress < deadZone) {\r\n        // near top -> snap to the top of this section\r\n        safeScrollTo(elTop);\r\n      } else if (progress > 1 - deadZone) {\r\n        // near bottom -> snap to next section top (if exists)\r\n        const next = sections[currentIndex + 1];\r\n        if (next) safeScrollTo(next.offsetTop);\r\n        else safeScrollTo(elTop);\r\n      } else {\r\n        // inside dead zone -> do nothing (allow normal scrolling)\r\n      }\r\n    };\r\n\r\n    // debounced scroll listener\r\n    const onScroll = () => {\r\n      if (timeoutRef.current) clearTimeout(timeoutRef.current);\r\n      timeoutRef.current = setTimeout(() => {\r\n        onScrollEnd();\r\n      }, 120); // small debounce to catch scroll-end\r\n    };\r\n\r\n    window.addEventListener('scroll', onScroll, { passive: true });\r\n\r\n    // cleanup\r\n    return () => {\r\n      window.removeEventListener('scroll', onScroll);\r\n      window.removeEventListener('resize', updateSections);\r\n      if (timeoutRef.current) {\r\n        clearTimeout(timeoutRef.current);\r\n        timeoutRef.current = null;\r\n      }\r\n      // if you used any observers, disconnect here (not used now)\r\n      if (resizeObserverRef.current) {\r\n        resizeObserverRef.current.disconnect();\r\n        resizeObserverRef.current = null;\r\n      }\r\n    };\r\n  }, [selector, duration, centerThreshold, deadZone]);\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}