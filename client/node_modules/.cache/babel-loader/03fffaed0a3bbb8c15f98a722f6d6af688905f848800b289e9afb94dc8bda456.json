{"ast":null,"code":"var _s = $RefreshSig$();\n// src/hooks/useScrollSnap.js\nimport { useEffect, useRef } from 'react';\nimport { gsap } from 'gsap';\n\n/**\r\n * Smart scroll snap hook with direction-awareness and GSAP ScrollTo support.\r\n *\r\n * Usage:\r\n *  - register GSAP ScrollToPlugin once (e.g. in App.jsx or index.js)\r\n *  - call useScrollSnap({ selector: 'section', duration: 0.8, centerThreshold: 0.15, deadZone: 0.2 })\r\n */\nexport default function useScrollSnap({\n  selector = 'section',\n  duration = 0.8,\n  // seconds for tween\n  centerThreshold = 0.25,\n  // fraction of section height for center tolerance (short sections)\n  deadZone = 0.3 // fraction of tall section that is free-scroll\n} = {}) {\n  _s();\n  const sectionsRef = useRef([]);\n  const debounceRef = useRef(null);\n  const isAutoScrollingRef = useRef(false);\n  const lastUserScrollRef = useRef(window.scrollY);\n  const lastDirectionRef = useRef('down');\n  const autoScrollClearRef = useRef(null);\n  useEffect(() => {\n    // collect sections\n    const collect = () => {\n      sectionsRef.current = Array.from(document.querySelectorAll(selector));\n    };\n    collect();\n    window.addEventListener('resize', collect);\n    const safeScrollTo = targetY => {\n      // do nothing if very close already\n      const current = Math.round(window.scrollY);\n      const dest = Math.round(targetY);\n      if (Math.abs(dest - current) <= 6) return Promise.resolve();\n      isAutoScrollingRef.current = true;\n      // clear any existing auto-scroll clear timers\n      if (autoScrollClearRef.current) {\n        clearTimeout(autoScrollClearRef.current);\n        autoScrollClearRef.current = null;\n      }\n\n      // Try GSAP ScrollTo (requires ScrollToPlugin registered). If it throws, fallback.\n      try {\n        return new Promise(resolve => {\n          const tween = gsap.to(window, {\n            duration,\n            scrollTo: {\n              y: dest\n            },\n            ease: 'power2.out',\n            onComplete: () => {\n              isAutoScrollingRef.current = false;\n              resolve();\n            },\n            onInterrupt: () => {\n              // if user interrupts, let go\n              isAutoScrollingRef.current = false;\n              resolve();\n            }\n          });\n        });\n      } catch (err) {\n        // fallback to native smooth scroll and clear the auto-scroll lock after duration (ms)\n        return new Promise(resolve => {\n          try {\n            window.scrollTo({\n              top: dest,\n              behavior: 'smooth'\n            });\n            autoScrollClearRef.current = setTimeout(() => {\n              isAutoScrollingRef.current = false;\n              resolve();\n            }, Math.max(300, duration * 1000));\n          } catch (err2) {\n            // last fallback: instant\n            window.scrollTo(0, dest);\n            isAutoScrollingRef.current = false;\n            resolve();\n          }\n        });\n      }\n    };\n    const handleScrollEnd = async () => {\n      const sections = sectionsRef.current;\n      if (!sections || sections.length === 0) return;\n      const scrollY = window.scrollY;\n      const vh = window.innerHeight;\n      const direction = lastDirectionRef.current; // 'down'|'up'\n\n      // determine which section contains the current scrollY\n      let indexContaining = sections.findIndex(el => {\n        const top = el.offsetTop;\n        const bottom = top + el.offsetHeight;\n        return scrollY >= top && scrollY < bottom;\n      });\n      if (indexContaining === -1) {\n        // if not found, find nearest by offsetTop distance\n        let minD = Infinity;\n        let idx = 0;\n        sections.forEach((el, i) => {\n          const d = Math.abs(el.offsetTop - scrollY);\n          if (d < minD) {\n            minD = d;\n            idx = i;\n          }\n        });\n        indexContaining = idx;\n      }\n      const el = sections[indexContaining];\n      const elTop = el.offsetTop;\n      const elHeight = el.offsetHeight;\n      const elBottom = elTop + elHeight;\n\n      // SHORT sections (<= viewport): use center of viewport to decide and require direction match\n      if (elHeight <= vh) {\n        const centerY = scrollY + vh / 2;\n        const centerFrac = (centerY - elTop) / elHeight; // 0..1\n\n        // If center is substantially above the midpoint and user scrolled up -> snap to this\n        if (direction === 'up' && centerFrac < 0.5 - centerThreshold) {\n          await safeScrollTo(elTop);\n          return;\n        }\n\n        // If center is substantially below the midpoint and user scrolled down -> snap to next\n        if (direction === 'down' && centerFrac > 0.5 + centerThreshold) {\n          const next = sections[indexContaining + 1];\n          if (next) {\n            await safeScrollTo(next.offsetTop);\n          }\n          return;\n        }\n\n        // Otherwise don't snap (user likely making a small scroll)\n        return;\n      }\n\n      // TALL sections: allow free scroll inside a central dead zone, snap near edges\n      // Compute progress within the scrollable inner range:\n      const totalScrollable = Math.max(0, elHeight - vh); // how far you can scroll inside this section\n      const progress = totalScrollable > 0 ? (scrollY - elTop) / totalScrollable : 0; // 0..1\n\n      // If user is near the top edge and scrolling up, snap to top\n      if (direction === 'up' && progress <= deadZone) {\n        await safeScrollTo(elTop);\n        return;\n      }\n\n      // If user is near the bottom edge and scrolling down, snap to next\n      if (direction === 'down' && progress >= 1 - deadZone) {\n        const next = sections[indexContaining + 1];\n        if (next) await safeScrollTo(next.offsetTop);\n        return;\n      }\n\n      // else inside dead zone -> do nothing (free scroll)\n      return;\n    };\n\n    // Debounced onScroll that tracks user direction and blocks when auto-scrolling\n    const onScroll = () => {\n      // ignore scroll events while we triggered an automatic scroll\n      if (isAutoScrollingRef.current) return;\n      const current = window.scrollY;\n      lastDirectionRef.current = current > lastUserScrollRef.current ? 'down' : 'up';\n      lastUserScrollRef.current = current;\n      if (debounceRef.current) clearTimeout(debounceRef.current);\n      debounceRef.current = setTimeout(() => {\n        handleScrollEnd();\n      }, 180); // slightly longer debounce to detect scroll \"end\"\n    };\n    window.addEventListener('wheel', onScroll, {\n      passive: true\n    });\n    window.addEventListener('touchmove', onScroll, {\n      passive: true\n    });\n    window.addEventListener('scroll', onScroll, {\n      passive: true\n    });\n\n    // cleanup\n    return () => {\n      window.removeEventListener('wheel', onScroll);\n      window.removeEventListener('touchmove', onScroll);\n      window.removeEventListener('scroll', onScroll);\n      window.removeEventListener('resize', collect);\n      if (debounceRef.current) clearTimeout(debounceRef.current);\n      if (autoScrollClearRef.current) clearTimeout(autoScrollClearRef.current);\n    };\n  }, [selector, duration, centerThreshold, deadZone]);\n}\n_s(useScrollSnap, \"Vr+bnLTui6/vrGtEG4KC5IfDm7c=\");","map":{"version":3,"names":["useEffect","useRef","gsap","useScrollSnap","selector","duration","centerThreshold","deadZone","_s","sectionsRef","debounceRef","isAutoScrollingRef","lastUserScrollRef","window","scrollY","lastDirectionRef","autoScrollClearRef","collect","current","Array","from","document","querySelectorAll","addEventListener","safeScrollTo","targetY","Math","round","dest","abs","Promise","resolve","clearTimeout","tween","to","scrollTo","y","ease","onComplete","onInterrupt","err","top","behavior","setTimeout","max","err2","handleScrollEnd","sections","length","vh","innerHeight","direction","indexContaining","findIndex","el","offsetTop","bottom","offsetHeight","minD","Infinity","idx","forEach","i","d","elTop","elHeight","elBottom","centerY","centerFrac","next","totalScrollable","progress","onScroll","passive","removeEventListener"],"sources":["C:/Users/georg/projects/Fullstack/portofolio-2.0/client/src/components/useScrollSnap.js"],"sourcesContent":["// src/hooks/useScrollSnap.js\r\nimport { useEffect, useRef } from 'react';\r\nimport { gsap } from 'gsap';\r\n\r\n/**\r\n * Smart scroll snap hook with direction-awareness and GSAP ScrollTo support.\r\n *\r\n * Usage:\r\n *  - register GSAP ScrollToPlugin once (e.g. in App.jsx or index.js)\r\n *  - call useScrollSnap({ selector: 'section', duration: 0.8, centerThreshold: 0.15, deadZone: 0.2 })\r\n */\r\nexport default function useScrollSnap({\r\n  selector = 'section',\r\n  duration = 0.8,        // seconds for tween\r\n  centerThreshold = 0.25, // fraction of section height for center tolerance (short sections)\r\n  deadZone = 0.3         // fraction of tall section that is free-scroll\r\n} = {}) {\r\n  const sectionsRef = useRef([]);\r\n  const debounceRef = useRef(null);\r\n  const isAutoScrollingRef = useRef(false);\r\n  const lastUserScrollRef = useRef(window.scrollY);\r\n  const lastDirectionRef = useRef('down');\r\n  const autoScrollClearRef = useRef(null);\r\n\r\n  useEffect(() => {\r\n    // collect sections\r\n    const collect = () => {\r\n      sectionsRef.current = Array.from(document.querySelectorAll(selector));\r\n    };\r\n    collect();\r\n    window.addEventListener('resize', collect);\r\n\r\n    const safeScrollTo = (targetY) => {\r\n      // do nothing if very close already\r\n      const current = Math.round(window.scrollY);\r\n      const dest = Math.round(targetY);\r\n      if (Math.abs(dest - current) <= 6) return Promise.resolve();\r\n\r\n      isAutoScrollingRef.current = true;\r\n      // clear any existing auto-scroll clear timers\r\n      if (autoScrollClearRef.current) {\r\n        clearTimeout(autoScrollClearRef.current);\r\n        autoScrollClearRef.current = null;\r\n      }\r\n\r\n      // Try GSAP ScrollTo (requires ScrollToPlugin registered). If it throws, fallback.\r\n      try {\r\n        return new Promise((resolve) => {\r\n          const tween = gsap.to(window, {\r\n            duration,\r\n            scrollTo: { y: dest },\r\n            ease: 'power2.out',\r\n            onComplete: () => {\r\n              isAutoScrollingRef.current = false;\r\n              resolve();\r\n            },\r\n            onInterrupt: () => {\r\n              // if user interrupts, let go\r\n              isAutoScrollingRef.current = false;\r\n              resolve();\r\n            }\r\n          });\r\n        });\r\n      } catch (err) {\r\n        // fallback to native smooth scroll and clear the auto-scroll lock after duration (ms)\r\n        return new Promise((resolve) => {\r\n          try {\r\n            window.scrollTo({ top: dest, behavior: 'smooth' });\r\n            autoScrollClearRef.current = setTimeout(() => {\r\n              isAutoScrollingRef.current = false;\r\n              resolve();\r\n            }, Math.max(300, duration * 1000));\r\n          } catch (err2) {\r\n            // last fallback: instant\r\n            window.scrollTo(0, dest);\r\n            isAutoScrollingRef.current = false;\r\n            resolve();\r\n          }\r\n        });\r\n      }\r\n    };\r\n\r\n    const handleScrollEnd = async () => {\r\n      const sections = sectionsRef.current;\r\n      if (!sections || sections.length === 0) return;\r\n\r\n      const scrollY = window.scrollY;\r\n      const vh = window.innerHeight;\r\n      const direction = lastDirectionRef.current; // 'down'|'up'\r\n\r\n      // determine which section contains the current scrollY\r\n      let indexContaining = sections.findIndex((el) => {\r\n        const top = el.offsetTop;\r\n        const bottom = top + el.offsetHeight;\r\n        return scrollY >= top && scrollY < bottom;\r\n      });\r\n\r\n      if (indexContaining === -1) {\r\n        // if not found, find nearest by offsetTop distance\r\n        let minD = Infinity;\r\n        let idx = 0;\r\n        sections.forEach((el, i) => {\r\n          const d = Math.abs(el.offsetTop - scrollY);\r\n          if (d < minD) {\r\n            minD = d;\r\n            idx = i;\r\n          }\r\n        });\r\n        indexContaining = idx;\r\n      }\r\n\r\n      const el = sections[indexContaining];\r\n      const elTop = el.offsetTop;\r\n      const elHeight = el.offsetHeight;\r\n      const elBottom = elTop + elHeight;\r\n\r\n      // SHORT sections (<= viewport): use center of viewport to decide and require direction match\r\n      if (elHeight <= vh) {\r\n        const centerY = scrollY + vh / 2;\r\n        const centerFrac = (centerY - elTop) / elHeight; // 0..1\r\n\r\n        // If center is substantially above the midpoint and user scrolled up -> snap to this\r\n        if (direction === 'up' && centerFrac < 0.5 - centerThreshold) {\r\n          await safeScrollTo(elTop);\r\n          return;\r\n        }\r\n\r\n        // If center is substantially below the midpoint and user scrolled down -> snap to next\r\n        if (direction === 'down' && centerFrac > 0.5 + centerThreshold) {\r\n          const next = sections[indexContaining + 1];\r\n          if (next) {\r\n            await safeScrollTo(next.offsetTop);\r\n          }\r\n          return;\r\n        }\r\n\r\n        // Otherwise don't snap (user likely making a small scroll)\r\n        return;\r\n      }\r\n\r\n      // TALL sections: allow free scroll inside a central dead zone, snap near edges\r\n      // Compute progress within the scrollable inner range:\r\n      const totalScrollable = Math.max(0, elHeight - vh); // how far you can scroll inside this section\r\n      const progress = totalScrollable > 0 ? (scrollY - elTop) / totalScrollable : 0; // 0..1\r\n\r\n      // If user is near the top edge and scrolling up, snap to top\r\n      if (direction === 'up' && progress <= deadZone) {\r\n        await safeScrollTo(elTop);\r\n        return;\r\n      }\r\n\r\n      // If user is near the bottom edge and scrolling down, snap to next\r\n      if (direction === 'down' && progress >= 1 - deadZone) {\r\n        const next = sections[indexContaining + 1];\r\n        if (next) await safeScrollTo(next.offsetTop);\r\n        return;\r\n      }\r\n\r\n      // else inside dead zone -> do nothing (free scroll)\r\n      return;\r\n    };\r\n\r\n    // Debounced onScroll that tracks user direction and blocks when auto-scrolling\r\n    const onScroll = () => {\r\n      // ignore scroll events while we triggered an automatic scroll\r\n      if (isAutoScrollingRef.current) return;\r\n\r\n      const current = window.scrollY;\r\n      lastDirectionRef.current = current > lastUserScrollRef.current ? 'down' : 'up';\r\n      lastUserScrollRef.current = current;\r\n\r\n      if (debounceRef.current) clearTimeout(debounceRef.current);\r\n      debounceRef.current = setTimeout(() => {\r\n        handleScrollEnd();\r\n      }, 180); // slightly longer debounce to detect scroll \"end\"\r\n    };\r\n\r\n    window.addEventListener('wheel', onScroll, { passive: true });\r\n    window.addEventListener('touchmove', onScroll, { passive: true });\r\n    window.addEventListener('scroll', onScroll, { passive: true });\r\n\r\n    // cleanup\r\n    return () => {\r\n      window.removeEventListener('wheel', onScroll);\r\n      window.removeEventListener('touchmove', onScroll);\r\n      window.removeEventListener('scroll', onScroll);\r\n      window.removeEventListener('resize', collect);\r\n      if (debounceRef.current) clearTimeout(debounceRef.current);\r\n      if (autoScrollClearRef.current) clearTimeout(autoScrollClearRef.current);\r\n    };\r\n  }, [selector, duration, centerThreshold, deadZone]);\r\n}"],"mappings":";AAAA;AACA,SAASA,SAAS,EAAEC,MAAM,QAAQ,OAAO;AACzC,SAASC,IAAI,QAAQ,MAAM;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASC,aAAaA,CAAC;EACpCC,QAAQ,GAAG,SAAS;EACpBC,QAAQ,GAAG,GAAG;EAAS;EACvBC,eAAe,GAAG,IAAI;EAAE;EACxBC,QAAQ,GAAG,GAAG,CAAS;AACzB,CAAC,GAAG,CAAC,CAAC,EAAE;EAAAC,EAAA;EACN,MAAMC,WAAW,GAAGR,MAAM,CAAC,EAAE,CAAC;EAC9B,MAAMS,WAAW,GAAGT,MAAM,CAAC,IAAI,CAAC;EAChC,MAAMU,kBAAkB,GAAGV,MAAM,CAAC,KAAK,CAAC;EACxC,MAAMW,iBAAiB,GAAGX,MAAM,CAACY,MAAM,CAACC,OAAO,CAAC;EAChD,MAAMC,gBAAgB,GAAGd,MAAM,CAAC,MAAM,CAAC;EACvC,MAAMe,kBAAkB,GAAGf,MAAM,CAAC,IAAI,CAAC;EAEvCD,SAAS,CAAC,MAAM;IACd;IACA,MAAMiB,OAAO,GAAGA,CAAA,KAAM;MACpBR,WAAW,CAACS,OAAO,GAAGC,KAAK,CAACC,IAAI,CAACC,QAAQ,CAACC,gBAAgB,CAAClB,QAAQ,CAAC,CAAC;IACvE,CAAC;IACDa,OAAO,CAAC,CAAC;IACTJ,MAAM,CAACU,gBAAgB,CAAC,QAAQ,EAAEN,OAAO,CAAC;IAE1C,MAAMO,YAAY,GAAIC,OAAO,IAAK;MAChC;MACA,MAAMP,OAAO,GAAGQ,IAAI,CAACC,KAAK,CAACd,MAAM,CAACC,OAAO,CAAC;MAC1C,MAAMc,IAAI,GAAGF,IAAI,CAACC,KAAK,CAACF,OAAO,CAAC;MAChC,IAAIC,IAAI,CAACG,GAAG,CAACD,IAAI,GAAGV,OAAO,CAAC,IAAI,CAAC,EAAE,OAAOY,OAAO,CAACC,OAAO,CAAC,CAAC;MAE3DpB,kBAAkB,CAACO,OAAO,GAAG,IAAI;MACjC;MACA,IAAIF,kBAAkB,CAACE,OAAO,EAAE;QAC9Bc,YAAY,CAAChB,kBAAkB,CAACE,OAAO,CAAC;QACxCF,kBAAkB,CAACE,OAAO,GAAG,IAAI;MACnC;;MAEA;MACA,IAAI;QACF,OAAO,IAAIY,OAAO,CAAEC,OAAO,IAAK;UAC9B,MAAME,KAAK,GAAG/B,IAAI,CAACgC,EAAE,CAACrB,MAAM,EAAE;YAC5BR,QAAQ;YACR8B,QAAQ,EAAE;cAAEC,CAAC,EAAER;YAAK,CAAC;YACrBS,IAAI,EAAE,YAAY;YAClBC,UAAU,EAAEA,CAAA,KAAM;cAChB3B,kBAAkB,CAACO,OAAO,GAAG,KAAK;cAClCa,OAAO,CAAC,CAAC;YACX,CAAC;YACDQ,WAAW,EAAEA,CAAA,KAAM;cACjB;cACA5B,kBAAkB,CAACO,OAAO,GAAG,KAAK;cAClCa,OAAO,CAAC,CAAC;YACX;UACF,CAAC,CAAC;QACJ,CAAC,CAAC;MACJ,CAAC,CAAC,OAAOS,GAAG,EAAE;QACZ;QACA,OAAO,IAAIV,OAAO,CAAEC,OAAO,IAAK;UAC9B,IAAI;YACFlB,MAAM,CAACsB,QAAQ,CAAC;cAAEM,GAAG,EAAEb,IAAI;cAAEc,QAAQ,EAAE;YAAS,CAAC,CAAC;YAClD1B,kBAAkB,CAACE,OAAO,GAAGyB,UAAU,CAAC,MAAM;cAC5ChC,kBAAkB,CAACO,OAAO,GAAG,KAAK;cAClCa,OAAO,CAAC,CAAC;YACX,CAAC,EAAEL,IAAI,CAACkB,GAAG,CAAC,GAAG,EAAEvC,QAAQ,GAAG,IAAI,CAAC,CAAC;UACpC,CAAC,CAAC,OAAOwC,IAAI,EAAE;YACb;YACAhC,MAAM,CAACsB,QAAQ,CAAC,CAAC,EAAEP,IAAI,CAAC;YACxBjB,kBAAkB,CAACO,OAAO,GAAG,KAAK;YAClCa,OAAO,CAAC,CAAC;UACX;QACF,CAAC,CAAC;MACJ;IACF,CAAC;IAED,MAAMe,eAAe,GAAG,MAAAA,CAAA,KAAY;MAClC,MAAMC,QAAQ,GAAGtC,WAAW,CAACS,OAAO;MACpC,IAAI,CAAC6B,QAAQ,IAAIA,QAAQ,CAACC,MAAM,KAAK,CAAC,EAAE;MAExC,MAAMlC,OAAO,GAAGD,MAAM,CAACC,OAAO;MAC9B,MAAMmC,EAAE,GAAGpC,MAAM,CAACqC,WAAW;MAC7B,MAAMC,SAAS,GAAGpC,gBAAgB,CAACG,OAAO,CAAC,CAAC;;MAE5C;MACA,IAAIkC,eAAe,GAAGL,QAAQ,CAACM,SAAS,CAAEC,EAAE,IAAK;QAC/C,MAAMb,GAAG,GAAGa,EAAE,CAACC,SAAS;QACxB,MAAMC,MAAM,GAAGf,GAAG,GAAGa,EAAE,CAACG,YAAY;QACpC,OAAO3C,OAAO,IAAI2B,GAAG,IAAI3B,OAAO,GAAG0C,MAAM;MAC3C,CAAC,CAAC;MAEF,IAAIJ,eAAe,KAAK,CAAC,CAAC,EAAE;QAC1B;QACA,IAAIM,IAAI,GAAGC,QAAQ;QACnB,IAAIC,GAAG,GAAG,CAAC;QACXb,QAAQ,CAACc,OAAO,CAAC,CAACP,EAAE,EAAEQ,CAAC,KAAK;UAC1B,MAAMC,CAAC,GAAGrC,IAAI,CAACG,GAAG,CAACyB,EAAE,CAACC,SAAS,GAAGzC,OAAO,CAAC;UAC1C,IAAIiD,CAAC,GAAGL,IAAI,EAAE;YACZA,IAAI,GAAGK,CAAC;YACRH,GAAG,GAAGE,CAAC;UACT;QACF,CAAC,CAAC;QACFV,eAAe,GAAGQ,GAAG;MACvB;MAEA,MAAMN,EAAE,GAAGP,QAAQ,CAACK,eAAe,CAAC;MACpC,MAAMY,KAAK,GAAGV,EAAE,CAACC,SAAS;MAC1B,MAAMU,QAAQ,GAAGX,EAAE,CAACG,YAAY;MAChC,MAAMS,QAAQ,GAAGF,KAAK,GAAGC,QAAQ;;MAEjC;MACA,IAAIA,QAAQ,IAAIhB,EAAE,EAAE;QAClB,MAAMkB,OAAO,GAAGrD,OAAO,GAAGmC,EAAE,GAAG,CAAC;QAChC,MAAMmB,UAAU,GAAG,CAACD,OAAO,GAAGH,KAAK,IAAIC,QAAQ,CAAC,CAAC;;QAEjD;QACA,IAAId,SAAS,KAAK,IAAI,IAAIiB,UAAU,GAAG,GAAG,GAAG9D,eAAe,EAAE;UAC5D,MAAMkB,YAAY,CAACwC,KAAK,CAAC;UACzB;QACF;;QAEA;QACA,IAAIb,SAAS,KAAK,MAAM,IAAIiB,UAAU,GAAG,GAAG,GAAG9D,eAAe,EAAE;UAC9D,MAAM+D,IAAI,GAAGtB,QAAQ,CAACK,eAAe,GAAG,CAAC,CAAC;UAC1C,IAAIiB,IAAI,EAAE;YACR,MAAM7C,YAAY,CAAC6C,IAAI,CAACd,SAAS,CAAC;UACpC;UACA;QACF;;QAEA;QACA;MACF;;MAEA;MACA;MACA,MAAMe,eAAe,GAAG5C,IAAI,CAACkB,GAAG,CAAC,CAAC,EAAEqB,QAAQ,GAAGhB,EAAE,CAAC,CAAC,CAAC;MACpD,MAAMsB,QAAQ,GAAGD,eAAe,GAAG,CAAC,GAAG,CAACxD,OAAO,GAAGkD,KAAK,IAAIM,eAAe,GAAG,CAAC,CAAC,CAAC;;MAEhF;MACA,IAAInB,SAAS,KAAK,IAAI,IAAIoB,QAAQ,IAAIhE,QAAQ,EAAE;QAC9C,MAAMiB,YAAY,CAACwC,KAAK,CAAC;QACzB;MACF;;MAEA;MACA,IAAIb,SAAS,KAAK,MAAM,IAAIoB,QAAQ,IAAI,CAAC,GAAGhE,QAAQ,EAAE;QACpD,MAAM8D,IAAI,GAAGtB,QAAQ,CAACK,eAAe,GAAG,CAAC,CAAC;QAC1C,IAAIiB,IAAI,EAAE,MAAM7C,YAAY,CAAC6C,IAAI,CAACd,SAAS,CAAC;QAC5C;MACF;;MAEA;MACA;IACF,CAAC;;IAED;IACA,MAAMiB,QAAQ,GAAGA,CAAA,KAAM;MACrB;MACA,IAAI7D,kBAAkB,CAACO,OAAO,EAAE;MAEhC,MAAMA,OAAO,GAAGL,MAAM,CAACC,OAAO;MAC9BC,gBAAgB,CAACG,OAAO,GAAGA,OAAO,GAAGN,iBAAiB,CAACM,OAAO,GAAG,MAAM,GAAG,IAAI;MAC9EN,iBAAiB,CAACM,OAAO,GAAGA,OAAO;MAEnC,IAAIR,WAAW,CAACQ,OAAO,EAAEc,YAAY,CAACtB,WAAW,CAACQ,OAAO,CAAC;MAC1DR,WAAW,CAACQ,OAAO,GAAGyB,UAAU,CAAC,MAAM;QACrCG,eAAe,CAAC,CAAC;MACnB,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;IACX,CAAC;IAEDjC,MAAM,CAACU,gBAAgB,CAAC,OAAO,EAAEiD,QAAQ,EAAE;MAAEC,OAAO,EAAE;IAAK,CAAC,CAAC;IAC7D5D,MAAM,CAACU,gBAAgB,CAAC,WAAW,EAAEiD,QAAQ,EAAE;MAAEC,OAAO,EAAE;IAAK,CAAC,CAAC;IACjE5D,MAAM,CAACU,gBAAgB,CAAC,QAAQ,EAAEiD,QAAQ,EAAE;MAAEC,OAAO,EAAE;IAAK,CAAC,CAAC;;IAE9D;IACA,OAAO,MAAM;MACX5D,MAAM,CAAC6D,mBAAmB,CAAC,OAAO,EAAEF,QAAQ,CAAC;MAC7C3D,MAAM,CAAC6D,mBAAmB,CAAC,WAAW,EAAEF,QAAQ,CAAC;MACjD3D,MAAM,CAAC6D,mBAAmB,CAAC,QAAQ,EAAEF,QAAQ,CAAC;MAC9C3D,MAAM,CAAC6D,mBAAmB,CAAC,QAAQ,EAAEzD,OAAO,CAAC;MAC7C,IAAIP,WAAW,CAACQ,OAAO,EAAEc,YAAY,CAACtB,WAAW,CAACQ,OAAO,CAAC;MAC1D,IAAIF,kBAAkB,CAACE,OAAO,EAAEc,YAAY,CAAChB,kBAAkB,CAACE,OAAO,CAAC;IAC1E,CAAC;EACH,CAAC,EAAE,CAACd,QAAQ,EAAEC,QAAQ,EAAEC,eAAe,EAAEC,QAAQ,CAAC,CAAC;AACrD;AAACC,EAAA,CApLuBL,aAAa","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}